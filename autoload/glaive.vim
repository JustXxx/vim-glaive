let s:thisplugin = expand('<sfile>:p:h:h')
let s:qargpattern = '\v\s*(\S+)%(\s+(.*))?$'
let s:cmdlinepattern = '\v\CGlaive[!]?\s*(\S*)\s*(.*)$'


""
" Installs this plugin. The maktaba library must be available: either make sure
" it's on your runtimepath or put it in the same directory as glaive and source
" the glaive bootstrap file. (If you source the bootstrap file, there is no need
" to call this function.)
function! glaive#Install() abort
  let l:glaive = maktaba#plugin#GetOrInstall(s:thisplugin)
  call l:glaive.Load('commands')
endfunction


" Returns completion candidates for the partial plugin name {string}.
function! s:CompletePluginName(string) abort
  let l:plugins = maktaba#plugin#RegisteredPlugins()
  let l:canonical_name = maktaba#plugin#CanonicalName(a:string)
  call filter(l:plugins, 'maktaba#string#StartsWith(v:val, l:canonical_name)')
  return l:plugins
endfunction


" Returns completion candidates for the partial flag operation {string} for
" plugin {plugin}.
function! s:CompleteOperation(plugin, string) abort
  let l:unaryop = matchstr(a:string, '\v^[!~]?')
  let l:flagstring = maktaba#string#StripLeading(a:string, '!~')
  if maktaba#string#EndsWith(l:flagstring, '=')
    " When flag ends in '=', complete with the current value.
    let l:flagname = substitute(l:flagstring, '\v[-+^$`]?\=$', '', '')
    try
      " l:Flagvalue must be capitalized because it may receive a Funcref.
      let l:Flagvalue = a:plugin.Flag(l:flagname)
    catch /ERROR(\(NotFound\|BadValue\)):/
      return []
    endtry
    return [l:unaryop . l:flagstring . string(l:Flagvalue)]
  else
    let l:flags = keys(a:plugin.flags)
    call filter(l:flags, 'maktaba#string#StartsWith(v:val, l:flagstring)')
    return map(l:flags, 'l:unaryop . v:val')
  endif
endfunction


""
" Custom completion for the :Glaive command. Completion is performed for the
" plugin name, the flag string, and the current flag value after '='. The names
" and meaning of {ArgLead}, {CmdLine}, and {CursorPos} are conventional, see
" |:command-completion-customlist|.
function! glaive#Complete(ArgLead, CmdLine, CursorPos) abort
  " This pattern must be somewhat permissive because ": ::4,'XGlaive! ..." is
  " entirely within possibility as the beginning of {CmdLine}.
  let l:nameendpos = matchend(a:CmdLine, '\v\CGlaive[!]?\s+\S*')
  if a:CursorPos <= l:nameendpos
    return s:CompletePluginName(a:ArgLead)
  else
    " s:cmdlinepattern must always match a:CmdLine.
    let [l:name, l:operations] = matchlist(a:CmdLine, s:cmdlinepattern)[1:2]
    try
      let l:plugin = maktaba#plugin#Get(l:name)
    catch /ERROR(NotFound):/
      return []
    endtry
    return s:CompleteOperation(l:plugin, a:ArgLead)
  endif
endfunction


""
" Given {qargs} (a quoted string given to the @command(Glaive) command, as
" generated by |<q-args>|), returns the plugin name and the configuration
" string.
" @throws BadValue if {qargs} has no plugin name.
function! glaive#SplitPluginNameFromOperations(qargs) abort
  let l:match = matchlist(a:qargs, s:qargpattern)
  if empty(l:match)
    throw maktaba#error#BadValue('Plugin missing in "%s"', a:qargs)
  endif
  return [l:match[1], l:match[2]]
endfunction


""
" Applies Glaive operations for {plugin} as described in {operations}.
" See @command(Glaive).
" @throws BadValue when the parsing of {operations} goes south.
" @throws WrongType when invalid flag operations are requested.
" @throws NotFound when a {operations} references a non-existent flag.
function! glaive#Configure(plugin, text) abort
  try
    let l:settings = maktaba#setting#ParseAll(maktaba#string#Strip(a:text))
  catch /ERROR(BadValue):/
    let [l:type, l:msg] = maktaba#error#Split(v:exception)
    let l:qualifier = 'Error parsing Glaive settings for %s: %s'
    throw maktaba#error#Message(l:type, l:qualifier, a:plugin.name, l:msg)
  endtry
  for l:setting in l:settings
    call l:setting.Apply(a:plugin)
  endfor
endfunction

""
" Gets {plugin}, which must already be on the runtimepath.
" Calls maktaba#plugin#Install on {plugin} if it has not yet been installed by
" maktaba. This will have no effect on non-maktaba plugins (which were already
" on the runtimepath), but will cause maktaba instant/* files to load (thus
" making their flags available).
"
" {plugin} will be passed through @function(maktaba#plugin#CanonicalName).
" Therefore, you can use anything which evaluates to the same canonical name:
" "my_plugin", "my-plugin", and even "my!plugin" are all equivalent.
"
" @throws NotFound if {plugin} cannot be found.
function! glaive#GetPlugin(plugin) abort
  " First, check whether the plugin was already registered with maktaba.
  try
    return maktaba#plugin#Get(a:plugin)
  catch /ERROR(NotFound):/
  endtry

  " Get the maktaba plugin object for a plugin already on the runtimepath.
  " If the plugin was installed with a plugin manager like pathogen or vundle,
  " then it's possible that it's on the runtimepath but hasn't been "Installed"
  " by maktaba. maktaba#plugin#Install is what forces the flags file to load
  " during vimrc time, so we need to make sure that the plugin has been
  " maktaba#plugin#Install'd before we can configure it.
  let l:canonical_name = maktaba#plugin#CanonicalName(a:plugin)
  let l:plugins = maktaba#rtp#LeafDirs()
  for l:key in keys(l:plugins)
    if maktaba#plugin#CanonicalName(l:key) ==# l:canonical_name
      return maktaba#plugin#GetOrInstall(l:plugins[l:key])
    endif
  endfor

  " If we're still here, we can't find the plugin.
  throw maktaba#error#NotFound('Plugin %s', a:plugin)
endfunction
